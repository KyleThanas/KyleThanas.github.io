(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{514:function(t,a,e){"use strict";e.r(a);var r=e(56),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),e("p",[e("a",{attrs:{name:"YKwL7"}})]),t._v(" "),e("h2",{attrs:{id:"http-1-x"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-x"}},[t._v("#")]),t._v(" http 1/x")]),t._v(" "),e("p",[e("a",{attrs:{name:"tdhXK"}})]),t._v(" "),e("h4",{attrs:{id:"http0-9流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http0-9流程"}},[t._v("#")]),t._v(" http0.9流程")]),t._v(" "),e("p",[t._v("客户端，构建请求，通过DNS查询IP地址，三次握手建立TCP连接，客户端发起请求，服务器响应，四次挥手，断开TCP连接。（一个来回：服务器收到请求信息，读取对应的文件如HTML，并将数据返回给客户端）\n"),e("a",{attrs:{name:"isc5b"}})]),t._v(" "),e("h4",{attrs:{id:"http1-0流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-0流程"}},[t._v("#")]),t._v(" http1.0流程")]),t._v(" "),e("p",[t._v("客户端，构建请求，通过DNS查询IP地址，三次握手建立TCP连接，客户端发起请求，服务器响应，四次挥手，断开TCP连接。（多个来回：HTTP1.0引入请求投和响应头，由于出现了如Js,css等多种形式的文本，http0.9以满足不了需求，so，引入了content-encoding，content-type等字段）\n"),e("a",{attrs:{name:"zJ0IG"}})]),t._v(" "),e("h4",{attrs:{id:"http-1-1出现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1出现"}},[t._v("#")]),t._v(" http 1.1出现")]),t._v(" "),e("p",[t._v("继承了"),e("code",[t._v("Http1.0")]),t._v("的优点，也克服了它的缺点，出现了"),e("code",[t._v("keep-alive")]),t._v("这个头部字段，它表示会在建立"),e("code",[t._v("TCP")]),t._v("连接后，完成首次的请求，并不会立刻断开"),e("code",[t._v("TCP")]),t._v("连接，而是保持这个连接状态～进而可以复用这个通道"),e("br"),t._v("Http 1.1并且支持请求管道化，“并行”发送请求，但是这个并行，也不是真正意义上的并行，而是可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）\n"),e("a",{attrs:{name:"0PzAv"}})]),t._v(" "),e("h4",{attrs:{id:"http-1-1的致命缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1的致命缺点"}},[t._v("#")]),t._v(" http 1.1的致命缺点")]),t._v(" "),e("ol",[e("li",[t._v("明文传输")]),t._v(" "),e("li",[t._v("其实还是没有解决无状态连接的")]),t._v(" "),e("li",[t._v("当有多个请求同时被挂起的时候 就会拥塞请求通道，导致后面请求无法发送")]),t._v(" "),e("li",[t._v("臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.")])]),t._v(" "),e("p",[e("a",{attrs:{name:"1Ua3U"}})]),t._v(" "),e("h2",{attrs:{id:"http-2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" http 2.0")]),t._v(" "),e("p",[t._v("相较于HTTP1.1，HTTP2.0的主要优点有采用二进制帧封装，传输变成多路复用，流量控制算法优化，服务器端推送，首部压缩，优先级等特点。\n"),e("a",{attrs:{name:"k9knb"}})]),t._v(" "),e("h4",{attrs:{id:"多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),e("p",[t._v("**所有的请求都是通过一个 TCP 连接并发完成。**HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完\n"),e("a",{attrs:{name:"8ZZhh"}})]),t._v(" "),e("h4",{attrs:{id:"流量控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[t._v("#")]),t._v(" 流量控制")]),t._v(" "),e("p",[t._v("TCP协议通过sliding window的算法来做流量控制。发送方有个sending window，接收方有receive window。http2.0的flow control是类似receive window的做法，数据的接收方通过告知对方自己的flow window大小表明自己还能接收多少数据。只有Data类型的frame才有flow control的功能。对于flow control，如果接收方在flow window为零的情况下依然更多的frame，则会返回block类型的frame，这张场景一般表明http2.0的部署出了问题。\n"),e("a",{attrs:{name:"903e1"}})]),t._v(" "),e("h4",{attrs:{id:"服务器端推送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器端推送"}},[t._v("#")]),t._v(" 服务器端推送")]),t._v(" "),e("p",[t._v("服务器端的推送，就是服务器可以对一个客户端请求发送多个响应。除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。当浏览器请求一个html，服务器其实大概知道你是接下来要请求资源了，而不需要等待浏览器得到html后解析页面再发送资源请求。\n"),e("a",{attrs:{name:"xMoZS"}})]),t._v(" "),e("h4",{attrs:{id:"首部压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首部压缩"}},[t._v("#")]),t._v(" 首部压缩")]),t._v(" "),e("ul",[e("li",[t._v("HTTP 2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送;通信期间几乎不会改变的通用键-值对(用户代理、可接受的媒体类型,等等)只需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求),那么 首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。")]),t._v(" "),e("li",[t._v("如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP 2.0 的连接存续期内始终存在,由客户端和服务器共同渐进地更新 。")]),t._v(" "),e("li",[t._v("本质上，当然是为了减少请求啦，通过多个js或css合并成一个文件，多张小图片拼合成Sprite图，可以让多个HTTP请求减少为一个，减少额外的协议开销，而提升性能。当然，一个HTTP的请求的body太大也是不合理的，有个度。文件的合并也会牺牲模块化和缓存粒度，可以把“稳定”的代码or 小图 合并为一个文件or一张Sprite，让其充分地缓存起来，从而区分开迭代快的文件。")])]),t._v(" "),e("p",[e("a",{attrs:{name:"NdTiM"}})]),t._v(" "),e("h2",{attrs:{id:"https"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" https")]),t._v(" "),e("p",[t._v("Http的那些致命缺陷，并没有完全解决，于是有了https，也是目前应用最广的协议之一"),e("br"),e("strong",[t._v("HTTP+ 加密 + 认证 + 完整性保护 =HTTPS ?")])]),t._v(" "),e("ul",[e("li",[t._v("如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。")]),t._v(" "),e("li",[t._v("另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。")]),t._v(" "),e("li",[t._v("为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS\n"),e("a",{attrs:{name:"KlADc"}})])]),t._v(" "),e("h4",{attrs:{id:"https-是身披-ssl-外壳的-http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-是身披-ssl-外壳的-http"}},[t._v("#")]),t._v(" HTTPS 是身披 SSL 外壳的 HTTP")]),t._v(" "),e("ul",[e("li",[t._v("HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（SecureSocket Layer）和TLS（Transport Layer Security）协议代替而已。")]),t._v(" "),e("li",[t._v("当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的HTTP。")]),t._v(" "),e("li",[t._v("在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全术。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/124615/1594886004280-960d2b91-1cac-4f7d-89e4-9eaa0638581d.png#align=left&display=inline&height=171&margin=%5Bobject%20Object%5D&name=image.png&originHeight=341&originWidth=800&size=118794&status=done&style=none&width=400",alt:"image.png"}}),t._v(" "),e("a",{attrs:{name:"Kpmrw"}})]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://juejin.im/post/5ee27de06fb9a047f7131eb2",target:"_blank",rel:"noopener noreferrer"}},[t._v("14期-连肝7个晚上，总结了计算机网络的知识点！（共66条）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000019891825",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么我们要熟悉这些通信协议？ 【精读】"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);