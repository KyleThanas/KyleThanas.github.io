(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{240:function(t,a,n){"use strict";n.r(a);var s=n(2),p=Object(s.a)({},function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"浏览器渲染过程（webkit）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程（webkit）","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器渲染过程（Webkit）")]),t._v(" "),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[t._v("在渲染方面我们要减少重排和重绘，因为他们会影响浏览器")]),n("span",{staticStyle:{"background-color":"transparent"}},[t._v("性能。可是，为什么，原理是什么呢？")])]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",{staticStyle:{"background-color":"transparent"}},[n("br")])]),n("p",{staticStyle:{"text-align":"center"}},[n("img",{staticStyle:{"max-width":"600px",width:"656.8px"},attrs:{alt:"image.png",title:"image.png",src:"https://cdn.nlark.com/yuque/0/2019/png/124615/1562051554245-1402caaf-0b9b-4d48-b1cd-70c938997066.png#align=left&display=inline&height=297&name=image.png&originHeight=371&originWidth=821&size=143135&status=done&width=656.8"}})]),n("p",{staticStyle:{"text-align":"center"}},[n("br")]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[t._v("浏览器的解释器，是包括在渲染引擎内的，我们常说的 ")]),n("span",[t._v("Chrome")]),n("span",[t._v("（现在使用的是 ")]),n("span",[t._v("Blink ")]),n("span",[t._v("引擎）和")]),n("span",[t._v("Safari ")]),n("span",[t._v("使用的")]),n("span",[t._v("Webkit ")]),n("span",[t._v("引擎， ")]),n("span",[t._v("Firefox ")]),n("span",[t._v("使用的 ")]),n("span",[t._v("Gecko ")]),n("span",[t._v("引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的 ")]),n("strong",[n("span",[t._v("HTML ")])]),n("strong",[n("span",[t._v("解释器")])]),n("span",[t._v("（渲染时用于构造 ")]),n("span",[t._v("DOM ")]),n("span",[t._v("树）、 ")]),n("strong",[n("span",[t._v("CSS ")])]),n("strong",[n("span",[t._v("解释器")])]),n("span",[t._v("（渲染时用于合成 ")]),n("span",[t._v("CSS ")]),n("span",[t._v("规则）还有我们的 ")]),n("strong",[n("span",[t._v("JS ")])]),n("strong",[n("span",[t._v("解释器")])]),n("span",[t._v("。不过后来，由于 ")]),n("span",[t._v("JS ")]),n("span",[t._v("的使用越来越重要，工作越来越繁杂，所以 ")]),n("span",[t._v("JS ")]),n("span",[t._v("解释器也渐渐独立出来，成为了单独的 ")]),n("span",[t._v("JS ")]),n("span",[t._v("引擎，就像众所周知的 ")]),n("strong",[n("span",[t._v("V8 ")])]),n("strong",[n("span",[t._v("引擎")])]),n("span",[t._v("，我们经常接触的 ")]),n("span",[t._v("Node.js ")]),n("span",[t._v("也是用的它。")])]),n("p",{staticStyle:{"text-align":"center"}},[n("img",{staticStyle:{"max-width":"600px",width:"534.4px"},attrs:{alt:"image.png",title:"image.png",src:"https://cdn.nlark.com/yuque/0/2019/png/124615/1562051834716-828bb4ec-722e-493f-8b63-a777ce61f5b8.png#align=left&display=inline&height=348&name=image.png&originHeight=435&originWidth=668&size=103353&status=done&width=534.4"}})]),n("p",{staticStyle:{"text-align":"center"}},[n("br")]),t._v(" "),n("h2",{attrs:{id:"dom-渲染层与-gpu-硬件加速"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dom-渲染层与-gpu-硬件加速","aria-hidden":"true"}},[t._v("#")]),t._v(" DOM 渲染层与 GPU 硬件加速")]),t._v(" "),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[t._v("一个页面是有许多许多层级组成的，他们就像千层面那样。")])]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[n("br")])]),n("p",{staticStyle:{"text-align":"center"}},[n("img",{staticStyle:{"max-width":"600px",width:"637.6px"},attrs:{alt:"image.png",title:"image.png",src:"https://cdn.nlark.com/yuque/0/2019/png/124615/1562051887578-1dfb9ac8-14e0-49ae-b9ab-cccce337ce51.png#align=left&display=inline&height=363&name=image.png&originHeight=454&originWidth=797&size=392493&status=done&width=637.6"}})]),n("p",{staticStyle:{"text-align":"center"}},[n("br")]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[t._v("页面的真实样子就是这样，是由多个 ")]),n("span",[t._v("DOM ")]),n("span",[t._v("元素渲染层（")]),n("span",[t._v("Layers")]),n("span",[t._v("）组成的，实际上一个页面在构建完 ")]),n("span",[t._v("render tree ")]),n("span",[t._v("之后，是经历了这样的流程才最终呈现在我们面前的。")])]),n("ul",[n("li",[n("span",[t._v("浏览器会先获取 ")]),n("span",[t._v("DOM ")]),n("span",[t._v("树并依据样式将其分割成多个独立的渲染层。")])]),n("li",[n("span",[t._v("CPU ")]),n("span",[t._v("将每个层绘制进绘图中。")])]),n("li",[n("span",[t._v("将位图作为纹理上传至 ")]),n("span",[t._v("GPU")]),n("span",[t._v("（显卡）绘制。")])]),n("li",[n("span",[t._v("GPU ")]),n("span",[t._v("将所有的渲染层缓存（如果下次上传的渲染层没有发生变化， ")]),n("span",[t._v("GPU 就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像。")])])]),n("p",[n("span",[t._v("从上面的步骤我们可以知道，")]),n("strong",[n("span",[t._v("布局是由 ")])]),n("strong",[n("span",[t._v("CPU ")])]),n("strong",[n("span",[t._v("处理的，而绘制则是由 ")])]),n("strong",[n("span",[t._v("GPU ")])]),n("strong",[n("span",[t._v("完成的")])]),n("span",[t._v("。")])]),t._v(" "),n("h2",{attrs:{id:"重排与重绘"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重排与重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 重排与重绘")]),t._v(" "),n("p",[n("span",[t._v("现在到我们的重头戏了，重排和重绘。")])]),n("ol",{attrs:{start:"1"}},[n("li",[n("strong",[t._v("重排（reflow）")]),t._v("：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸"),n("br"),t._v("发生变化、删除或添加 DOM 元素，修改了影响元素盒子大小的 CSS 属性（诸如： width、 height、"),n("br"),t._v("padding）。")]),n("li",[n("strong",[t._v("重绘（repaint）")]),t._v("：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。")])]),n("p",[n("span",[t._v("我们习惯使用 ")]),n("span",[t._v("chrome devtools ")]),n("span",[t._v("中的 ")]),n("span",[t._v("performance ")]),n("span",[t._v("版块来测量页面重排重绘所占据的时间")])]),n("p",{staticStyle:{"text-align":"center"}},[n("img",{staticStyle:{"max-width":"600px",width:"276.8px"},attrs:{alt:"image.png",title:"image.png",src:"https://cdn.nlark.com/yuque/0/2019/png/124615/1562037345801-fc22ef4c-a591-42d9-85c2-f8ecda31dd83.png#align=left&display=inline&height=161&name=image.png&originHeight=201&originWidth=346&size=13752&status=done&width=276.8"}})]),n("p",{staticStyle:{"text-align":"center"}},[n("br")]),n("ul",[n("li",[n("span",[t._v("蓝色部分： ")]),n("span",[t._v("HTML ")]),n("span",[t._v("解析和网络通信占用的时间")])]),n("li",[t._v("黄色部分： "),n("span",{staticStyle:{"background-color":"transparent"}},[t._v("JavaScript ")]),n("span",{staticStyle:{"background-color":"transparent"}},[t._v("语句执行所占用时")]),t._v("间")]),n("li",[n("span",{staticStyle:{"background-color":"transparent"}},[t._v("紫色部分：重排占用时间")])]),n("li",[n("span",{staticStyle:{"background-color":"transparent"}},[t._v("绿色部分：重绘占用时间")])])]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[t._v("不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。")])]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[t._v("重排是由 ")]),n("span",[t._v("CPU ")]),n("span",[t._v("处理的，而重绘是由 ")]),n("span",[t._v("GPU ")]),n("span",[t._v("处理的，")]),n("span",[t._v("CPU ")]),n("span",[t._v("的处理效率远不及 ")]),n("span",[t._v("GPU")]),n("span",[t._v("，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。")])]),n("p",{staticStyle:{"text-indent":"2em"}},[n("span",[n("br")])]),n("p",{staticStyle:{"text-align":"center"}},[n("img",{staticStyle:{"max-width":"600px",width:"1536px"},attrs:{alt:"image.png",title:"image.png",src:"https://cdn.nlark.com/yuque/0/2019/png/124615/1562037315116-cb23d734-6f84-4b25-a4f4-dbd183a6ad20.png#align=left&display=inline&height=722&name=image.png&originHeight=903&originWidth=1920&size=142797&status=done&width=1536"}})]),t._v(" "),n("h2",{attrs:{id:"优化策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化策略","aria-hidden":"true"}},[t._v("#")]),t._v(" 优化策略")]),t._v(" "),n("ol",{attrs:{start:"1"}},[n("li",[n("span",[t._v("CSS ")]),n("span",[t._v("属性读写分离：浏览器没次对元素样式进行读操作时，都必须进行一次重新渲染（重排 ")]),n("span",[t._v("+")]),n("span",[t._v("重绘），所以我们在使用 ")]),n("span",[t._v("JS ")]),n("span",[t._v("对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用 ")]),n("span",[t._v("JS ")]),n("span",[t._v("去操作元素样式，这也是我最推荐的。")])]),n("li",[n("span",[t._v("通过切换 ")]),n("span",[t._v("class ")]),n("span",[t._v("或者 ")]),n("span",[t._v("style.csstext ")]),n("span",[t._v("属性去批量操作元素样式")])]),n("li",[n("span",[t._v("DOM ")]),n("span",[t._v("元素离线更新：当对 ")]),n("span",[t._v("DOM ")]),n("span",[t._v("进行相关操作时，例、 ")]),n("span",[t._v("appendChild ")]),n("span",[t._v("等都可以使用 ")]),n("span",[t._v("Document"),n("br"),t._v("Fragment ")]),n("span",[t._v("对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用 ")]),n("span",[t._v("display:none ")]),n("span",[t._v("对元素隐藏，"),n("br"),t._v("在元素“消失”后进行相关操作")])]),n("li",[n("span",[t._v("将没用的元素设为不可见： ")]),n("span",[t._v("visibility: hidden")]),n("span",[t._v("，这样可以减小重绘的压力，必要的时候再将元素显示")])]),n("li",[n("span",[t._v("压缩 ")]),n("span",[t._v("DOM ")]),n("span",[t._v("的深度，一个渲染层内不要有过深的子元素，少用 ")]),n("span",[t._v("DOM ")]),n("span",[t._v("完成页面样式，多使用伪"),n("br"),t._v("元素或者 ")]),n("span",[t._v("box-shadow ")]),n("span",[t._v("取代")])]),n("li",[n("span",[t._v("图片在渲染前指定大小：因为 ")]),n("span",[t._v("img ")]),n("span",[t._v("元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流")])]),n("li",[n("span",[t._v("对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 ")]),n("span",[t._v("GPU ")]),n("span",[t._v("分担 ")]),n("span",[t._v("CPU ")]),n("span",[t._v("压力。（这项策略需要慎用，得着重考量以牺牲 ")]),n("span",[t._v("GPU ")]),n("span",[t._v("占用率能否换来可期的性能优化，毕竟页面中存在太多的渲染层对与 ")]),n("span",[t._v("GPU ")]),n("span",[t._v("而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。）")])])])])},[],!1,null,null,null);a.default=p.exports}}]);